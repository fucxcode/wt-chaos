import { Entity, Id } from "./entities";
import { Driver, InsertOneOptions, InsertManyOptions, CountOptions, FindOneOptions, FindOptions, UpdateOptions, UpdateResult, DeleteOptions, DeleteResult, FindOneAndUpdateOptions, BulkOperation, AggregateOptions, MapReduceOptions, Session } from "./drivers";
import { OperationDescription } from "./operation-desc";
import { Plugin } from "./plugins/plugin";
import { SavePluginContext } from "./plugins/contexts/plugin-context-save";
import { CountPluginContext } from "./plugins/contexts/plugin-context-count";
import { ErasePluginContext } from "./plugins/contexts/plugin-context-erase";
import { FindByPageIndexResult } from "./find-by-page-index-result";
import { FindByPageNextResult } from "./find-by-page-next-result";
declare abstract class Repository<TSession extends Session, TID extends Id, TDriver extends Driver<TSession, TID>, TEntity extends Entity> {
    private _driver;
    readonly driver: TDriver;
    private _plugins;
    readonly plugins: Plugin[];
    private _collectionName;
    readonly collectionName: string;
    constructor(collectionName: string, driver: TDriver, plugins?: Plugin[]);
    private processPluginBeforeActions;
    private processPluginAfterActions;
    protected onSave(context: SavePluginContext<TEntity, TSession>): Promise<void>;
    save(operationDescription: OperationDescription, entityOrArray: TEntity | TEntity[], options?: InsertOneOptions<TSession> | InsertManyOptions<TSession>): Promise<Partial<TEntity> | Partial<TEntity>[] | undefined>;
    protected onCount(context: CountPluginContext<TSession>): Promise<void>;
    count(operationDescription: OperationDescription, condition?: any, options?: CountOptions<TSession>): Promise<number>;
    protected onFind(operationDescription: OperationDescription, condition?: any, options?: FindOptions<TEntity, TSession>): Promise<Partial<TEntity>[]>;
    private findOneInternal;
    findOne(operationDescription: OperationDescription, condition?: any, throwErrorWhenMultipleDocuments?: boolean, options?: FindOptions<TEntity, TSession>): Promise<Partial<TEntity> | undefined>;
    findOneById(operationDescription: OperationDescription, id: Id, condition?: any, options?: FindOneOptions<TEntity, TSession>): Promise<Partial<TEntity> | undefined>;
    findByIds(operationDescription: OperationDescription, ids: Id[], condition?: any, options?: FindOptions<TEntity, TSession>): Promise<Partial<TEntity>[]>;
    findByPageIndex(operationDescription: OperationDescription, condition?: any, pageIndex?: number, pageSize?: number, options?: FindOptions<TEntity, TSession>): Promise<FindByPageIndexResult<TEntity>>;
    findByPageNext(operationDescription: OperationDescription, condition?: any, pageIndex?: number, pageSize?: number, options?: FindOptions<TEntity, TSession>): Promise<FindByPageNextResult<TEntity>>;
    private parseUpdate;
    private parseUpdateFromEntity;
    protected onUpdate(operationDescription: OperationDescription, condition?: any, update?: any, multi?: boolean, options?: UpdateOptions<TSession>): Promise<UpdateResult>;
    update(operationDescription: OperationDescription, condition?: any, update?: any, multi?: boolean, options?: UpdateOptions<TSession>): Promise<UpdateResult>;
    updateById(operationDescription: OperationDescription, id: Id, condition?: any, update?: any, options?: UpdateOptions<TSession>): Promise<UpdateResult>;
    updateByIds(operationDescription: OperationDescription, ids: Id[], condition?: any, update?: any, options?: UpdateOptions<TSession>): Promise<UpdateResult>;
    updateByEntity(operationDescription: OperationDescription, entity: TEntity, condition?: any, options?: UpdateOptions<TSession>): Promise<UpdateResult>;
    protected onErase(context: ErasePluginContext<TSession>, multi: boolean): Promise<void>;
    protected erase(operationDescription: OperationDescription, condition?: any, multi?: boolean, options?: DeleteOptions<TSession>): Promise<DeleteResult>;
    protected onFindOneAndUpdate(operationDescription: OperationDescription, condition?: any, update?: any, options?: FindOneAndUpdateOptions<TEntity, TSession>): Promise<Partial<TEntity> | undefined>;
    findOneAndUpdate(operationDescription: OperationDescription, condition?: any, update?: any, options?: FindOneAndUpdateOptions<TEntity, TSession>): Promise<Partial<TEntity> | undefined>;
    findOneAndUpdateByEntity(operationDescription: OperationDescription, entity: TEntity, condition?: any, options?: FindOneAndUpdateOptions<TEntity, TSession>): Promise<Partial<TEntity> | undefined>;
    initializeBulkOp(operationDescription: OperationDescription, ordered?: boolean): BulkOperation;
    aggregate<TResult>(operationDescription: OperationDescription, pipeline: any[], options?: AggregateOptions<TSession>): Promise<Partial<TResult>[]>;
    mapReduce<TResult>(operationDescription: OperationDescription, map: Function | string, reduce: Function | string, options?: MapReduceOptions<TSession>): Promise<Partial<TResult>[]>;
}
export { Repository, FindByPageIndexResult, FindByPageNextResult };
